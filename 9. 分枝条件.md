# 分枝条件

不幸的是，刚才那个表达式也能匹配 010)12345678 或(022-87654321 这样的“不正确”的格式。

要解决这个问题，我们需要用到分枝条件。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用 `|` 把不同的规则分隔开。听不明白？没关系，看例子：

```
0\d{2}-\d{8}|0\d{3}-\d{7}
```

这个表达式能匹配两种以连字号分隔的电话号码：

* 一种是三位区号，8位本地号(如 010-12345678 )
* 一种是四位区号，7位本地号( 0376-2233445 )

```
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}
```

这个表达式匹配 3 位区号的电话号码，其中**区号可以用小括号括起来，也可以不用**，区号与本地号间**可以用连字号或空格间隔，也可以没有间隔**。*你可以试试用分枝条件把这个表达式扩展成也支持4位区号的*。

```
\d{5}-\d{4}|\d{5}
```

这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

